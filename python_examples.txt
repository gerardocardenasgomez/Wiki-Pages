====Python Examples====

====Removing Special Characters====

It is always useful to remove special characters from strings. In this example, there is input from an unknown user that must be cleansed of special chracters before the string can be processed further:

<code>
import re
dangerous_string = raw_input("Enter a string: ")

clean_string = re.sub('\W+', '', dangerous_string)

if not clean_string.isalnum():
    print "No special characters allowed"
</code>

The ''string.isalnum()'' method will return ''True'' if there are no special characters in the string. This is just a final check to make absolutely sure that there are no special characters in the string. One thing to note is the variable names that are used, such as ''dangerous_string'' and ''clean_string''. This is to ensure that there is no mistake made further down the program because it is clear when a string that hasn't been cleansed is being used.

====Named Tuples====

''namedtuples'' can be used to build classes of objects that have no custom methods, but instead act like a database record might. In this example, we create a card ''namedtuple'' and fetch attributes from it:

<code>
>>> import collections
>>> Card = collections.namedtuple('Card', ['rank', 'suit'])
>>> your_card = Card('7', 'Diamonds')
>>> your_card
Card(rank='7', suit='Diamonds')
>>> your_card.rank
'7'
>>> your_card.suit
'Diamonds'
</code>

''namedtuples'' are different from regular tuples in that regular tuples use indexes to access the different values:

<code>
>>> things = ('car','table','chair')
>>> things[0]
'car'
</code>

''namedtuples'' can use names for the different attributes, and this is a huge benefit because now there's no need for remembering the right index number. In this example, we use ''namedtuples'' as you might use a database field:

<code>
>>> Employee = collections.namedtuple('Employee', 'name title office')
>>> bob = Employee(name='Bob', title='Marketing Director', office='110')
>>> bob.name
'Bob'
>>> bob.title
'Marketing Director'
>>> bob.office
'110'
</code>

Each attribute can be accessed using dot notation.

====Generators====

Generators can be used to process large amounts of data in an efficient manner. The only caveat is that generators are stateful. They create an iterator which is then used to access the data in the generator but it is not possible to choose specific elements in the generator. This is memory-efficient. Generators are especially useful when it's uncertain how much data will be processed, or for example when processing data coming from a network socket which may be infinite. In this example, a list is used to process the length of each line in a file and then a generator expression is used instead:

<code>
lines = [len(x) for x in open('data.txt')]

iter = (len(x) for x in open('data.txt'))
print iter    # <generator object <genexpr> at 0x101b81480>
</code>

The benefit of using a generator expression is not as huge when you're processing only small amounts of data. But they come in very useful when the file being processed reaches into the GBs in size.
